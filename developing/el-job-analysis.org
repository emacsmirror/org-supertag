#+TITLE: El-job 工作原理分析
#+DATE: [2024-03-30 Sat]
#+AUTHOR: Yi Bin Chen
#+OPTIONS: ^:nil

* El-job 概述

El-job 是一个用于 Emacs 的异步多核心任务处理库。它的主要目标是：

1. 利用多核 CPU 加速任务处理
2. 避免阻塞主 Emacs 进程
3. 保持子进程常驻以减少启动开销

* 公共 API

** 主要函数
*** el-job-launch
主要的任务启动函数，用于异步执行任务：
#+begin_src elisp
(el-job-launch
  :funcall FUNCTION     ; 要执行的函数
  :callback CALLBACK    ; 回调函数
  :name "task-name")    ; 任务名称（可选）
#+end_src

*** el-job-await
等待任务完成：
#+begin_src elisp
(el-job-await JOB-ID)  ; 阻塞直到指定任务完成
#+end_src

*** el-job-is-busy
检查任务是否正在运行：
#+begin_src elisp
(el-job-is-busy JOB-ID)  ; 返回 t 如果任务正在运行
#+end_src

** 版本信息
- =el-job-major-version= - 主版本号变量

* 开发者工具

** 调试命令
*** el-job-cycle-debug-level
循环切换调试级别：
#+begin_src elisp
M-x el-job-cycle-debug-level
#+end_src

*** el-job-show-info
显示当前 el-job 状态信息：
#+begin_src elisp
M-x el-job-show-info
#+end_src

*** el-job-kill-all
终止所有 el-job 进程：
#+begin_src elisp
M-x el-job-kill-all
#+end_src

* 核心设计

** 进程池设计
- 创建与 CPU 核心数相当的子进程
- 子进程常驻内存，避免反复启动开销
- 每个子进程独立处理任务，互不干扰

** 任务分发机制
- 主进程将任务分配给空闲的子进程
- 子进程执行完任务后返回结果
- 主进程通过回调处理结果

** 数据交换格式
- 所有数据必须是可序列化的 Lisp 对象
- 不支持 #<...> 格式的数据（如 buffer、marker 等）
- 返回值必须是固定长度的列表，每个元素也是列表

* 使用注意事项

** 数据格式要求
1. 返回值必须是固定长度的列表
2. 列表中每个元素也必须是列表
3. 示例：
   #+begin_src elisp
   (list 
    (if missing-file (list missing-file))  ; 长度 0 或 1 的列表
    (if file-mtime (list file-mtime))      ; 长度 0 或 1 的列表
    found-nodes                            ; 任意长度列表
    org-node-parser--paths-types           ; 任意长度列表
    org-node-parser--found-links           ; 任意长度列表
    (if problem (list problem)))           ; 长度 0 或 1 的列表
   #+end_src

** 不支持的数据类型
- Buffer 对象 (#<buffer name>)
- Marker 对象 (#<marker at pos>)
- Process 对象 (#<process name>)
- Window 对象 (#<window N>)
- 其他非可打印对象

** 子进程管理
1. 子进程会常驻内存
2. 可以通过 =M-x list-processes= 查看
3. 安全终止：使用 =el-job-kill-all=

* 在 org-supertag-sync 中的应用

** 初始化
#+begin_src elisp
;; 在 org-supertag-sync-init 中
(unless org-supertag-sync--job-id
  (setq org-supertag-sync--job-id (make-symbol "org-supertag-sync"))
  (el-job--spawn-processes org-supertag-sync--job-id org-supertag-sync-max-jobs))
#+end_src

** 文件同步
#+begin_src elisp
(el-job-launch
  :funcall (lambda ()
             (require 'org)
             (require 'org-element)
             (require 'org-supertag-db)
             ;; 处理文件...
             )
  :callback (lambda (result)
             ;; 处理结果...
             )
  :name "file-sync")
#+end_src

** 节点同步
#+begin_src elisp
(el-job-launch
  :funcall (lambda ()
             ;; 处理单个节点...
             )
  :callback (lambda (result)
             ;; 更新数据库...
             )
  :name "node-sync")
#+end_src

* 性能优化建议

1. 合理设置 =org-supertag-sync-max-jobs=
   - 建议设置为 (CPU 核心数 - 1)
   - 保留一个核心给主 Emacs 进程

2. 批量处理
   - 将多个小任务合并成一个大任务
   - 减少进程间通信开销

3. 数据预处理
   - 在发送给子进程前处理好数据
   - 确保数据格式符合要求

4. 错误处理
   - 在子进程中捕获所有可能的错误
   - 返回统一的错误格式

* 调试技巧

1. 使用内置调试工具
   #+begin_src elisp
   M-x el-job-cycle-debug-level  ; 切换调试级别
   M-x el-job-show-info         ; 显示状态信息
   #+end_src

2. 检查进程状态
   #+begin_src elisp
   M-x list-processes
   #+end_src

3. 监控任务队列
   #+begin_src elisp
   (org-supertag-sync-status)
   #+end_src

4. 终止所有进程
   #+begin_src elisp
   M-x el-job-kill-all
   #+end_src

* 参考链接

- [[https://github.com/meedstrom/el-job/tree/v0.3][El-job GitHub Repository]]
- [[https://github.com/meedstrom/el-job/blob/v0.3/README.org][El-job Documentation]]

* 常见错误及解决方案

** 参数错误
*** 错误：void-function el-job-run
=el-job-run= 不是正确的函数名，应该使用 =el-job-launch=。

*** 错误：Keyword argument :funcall not one of (:id :if-busy :load-features :inject-vars :inputs :funcall-per-input :callback)
=el-job-launch= 不支持 =:funcall= 参数，应该使用 =:funcall-per-input=。

*** 错误：Keyword argument :name not one of (:id :if-busy :load-features :inject-vars :inputs :funcall-per-input :callback)
=el-job-launch= 不支持 =:name= 参数。

*** 错误：Argument FUNCALL-PER-INPUT must be a symbol with a function definition
=:funcall-per-input= 参数必须是一个已定义的函数符号，不能是 lambda 表达式。

*** 错误：Argument CALLBACK must be a symbol with a function definition
=:callback= 参数也必须是一个已定义的函数符号，不能是 lambda 表达式。

*** 错误：Argument ID now mandatory
=el-job-launch= 现在要求必须提供 =:id= 参数，用于唯一标识任务。

*** 错误：void-function in child process
子进程找不到函数定义，需要使用 =:load-features= 和 =:load-path= 参数加载必要的文件：
#+begin_src elisp
(let* ((emacs-dir (expand-file-name user-emacs-directory))
       (package-dir (expand-file-name "elpa" emacs-dir))
       (load-path-list (list
                       default-directory              ; 当前目录
                       package-dir                    ; 包目录
                       ;; 动态查找包目录（注意包名格式）
                       (car (directory-files (expand-file-name "ht-" package-dir) 
                                           t "^[0-9]" t))  ; ht-20230923.1314/
                       (car (directory-files (expand-file-name "org-" package-dir)
                                           t "^[0-9]" t))))) ; org-9.6.1/
  (el-job-launch
   :id 'my-task
   :load-path load-path-list                    ; 设置加载路径
   :load-features '(org org-element ht)         ; 加载必要的功能
   :inputs inputs
   :funcall-per-input 'my-function
   :callback 'my-callback))
#+end_src

注意事项：
1. 确保提供所有必要的加载路径
2. 动态查找包的最新版本目录
   - 包目录名通常格式为：包名-版本号
   - 例如：ht-20230923.1314, org-9.6.1
3. 按正确的顺序加载功能（处理依赖关系）
4. 验证所有必要的功能都已加载
5. 使用 =M-x list-load-path-shadows= 检查加载路径冲突

** 正确的使用方式
#+begin_src elisp
;; 1. 首先定义处理函数和回调函数
(defun my-process-function (input)
  (do-something input))

(defun my-callback-function (result)
  (handle-result result))

;; 2. 然后使用 el-job-launch
(el-job-launch
 :id (intern (format "my-task-%s" (secure-hash 'sha1 some-input))) ; 唯一任务 ID
 :load-features '(my-package)           ; 加载必要的文件
 :inputs (list some-input)              ; 输入数据列表
 :funcall-per-input 'my-process-function ; 处理函数符号
 :callback 'my-callback-function)        ; 回调函数符号

;; 错误示例 - 缺少 :id 参数
(el-job-launch
 :inputs (list some-input)              ; 这样会报错！
 :funcall-per-input 'my-process-function
 :callback 'my-callback-function)
#+end_src

** 最佳实践
1. 总是使用命名函数作为处理函数
2. 确保处理函数在子进程中能正确加载所需的库
3. 不要使用不支持的参数
4. 确保输入数据是可序列化的
5. 在回调函数中正确处理结果

** 调试技巧
1. 使用 =M-x el-job-show-info= 查看任务状态
2. 检查处理函数是否正确定义
3. 确保所需的库都已经加载
4. 使用 =M-x el-job-cycle-debug-level= 增加调试信息 
# org-supertag 的设计

- tag 的表现形式为 #tag-name 
  - 不使用 org-mode 的 tag 功能，是因为 org-mode 的 tag 功能是用于组织文件的，而 org-supertag 是用于组织信息的
  - 另外，这样也可避免影响原有的 org-mode 的 tag 功能（已知有很多第三方插件的功能实现，依赖于 org-mode 的 tag 功能） 


## 基本设计

## Tana 中数据实体关系精炼整理

### 1. 核心实体关系

* **File:** 文件是 Tana 存储数据的基本单位，每个文件包含多个节点。
* **Node:**  节点是 Tana 中最小的信息单元，只有绑定了 Supertag 的 headline 才能被视为 node。 每个 node 拥有唯一的 node-id 和 file-path，并可以绑定多个 Supertag。
* **Supertag:**  Supertag 是对节点进行分类和赋予特殊属性的标签，每个 Supertag 拥有唯一的 tag-id，可以绑定到多个 Node 上，并可以定义多个 Field。
* **Field:**  Field 是 Supertag 的属性，用于描述 Supertag 所代表对象的特征，每个 Field 拥有唯一的名称和类型，并存储在 Field-values 表中。

### 2. 实体间关系详解

*  **Node 与 Supertag:**  Node 可以绑定多个 Supertag，Supertag 也可以绑定到多个 Node 上，形成多对多的关系。Node 通过绑定 Supertag 获得 Supertag 定义的 Fields。
*  **Supertag 与 Field:**  Supertag 可以定义多个 Field，Field 从属于 Supertag，不直接与 Node 关联。
*  **Node 与 Field:**  Node 不直接与 Field 关联，而是通过 Supertag 间接关联。 当 Node 绑定了某个 Supertag，就拥有了该 Supertag 定义的所有 Fields。
* **Supertag 之间的继承关系:**  子标签继承父标签的 Fields，但子标签自定义的 Fields 优先级更高。
* **Supertag 之间的组合关系:**  两个 Supertag 可以属于平等关系，它们的 Fields 会平等地展示在 Node 上。


### 3.  其他说明

*  Field 具备唯一性，用户不能创建名称重复的 Field。
*  Field 实例以 Property 的形式存储在 Node 下方，其值也同时存储在 Field-values 表中，两者保持一致。
*  Field 通过创建 Tag 模板的形式与对应的 Tag 进行关联。
*  Field 可以设置触发器，在特定事件发生时触发特定操作。
*  Field 可以加载 AI Prompt，利用 AI 的能力进行自动填充或其他操作。




## 01 SuperTag

### 1. Tag 的定义和作用

在 Tana 中，tag 更准确的称呼是 Supertag (超级标签)，它是将普通节点 (node) 转变为特定对象的关键工具。Supertag 不仅仅是简单的标签，更像是赋予节点“身份”和“属性”的特殊标记。通过为节点添加 Supertag，可以将节点归类到特定的对象集合中，并赋予其 Supertag 预设的字段 (Field) 和节点模板。 

例如，"购买牛奶" 这个节点可以添加  #task  这个 Supertag，使其成为一个任务对象，并自动拥有  #task 预设的截止日期、优先级等 Fields。

### 2. Tag 的创建和管理

* **创建 Supertag：**  
    * 在任意节点中输入 "#" 符号，会弹出 Supertag 菜单，继续输入 Supertag 名称即可创建新的 Supertag 或选择已有的 Supertag。
    * 使用命令行 (Cmd/Ctrl+K) 并输入 "Convert to supertag"，可以将当前节点转换为 Supertag 定义节点，并将子节点和字段转换为模板内容。
* **添加/删除 Supertag：** 
    * 在节点中输入 "#[标签名称]" 并回车即可添加 Supertag。
    * 将鼠标悬停在 Supertag 上，点击出现的 "x" 即可删除 Supertag。
    * 也可以通过命令行 (Cmd/Ctrl+K) 执行 "Add tag" 或 "Remove tag" 命令。
* **删除 Supertag 定义：** 
    * 在 Supertag 配置面板中可以删除 Supertag 定义。
    * 找到 Supertag 定义节点并删除。
    * 如果 Supertag 已经被应用到其他节点上，删除定义后，这些节点会显示一个垃圾桶图标，点击即可恢复 Supertag 定义。

### 3. Tag 页面

点击 Supertag 可以进入 Tag 页面，默认以 Tabs 视图展示，第一个 Tab 显示所有拥有该 Supertag 的节点列表。

* **Tag 页面配置：** 可以在 Tag 页面进行基本配置，例如添加列 (即 Fields) 并保存到 Supertag 模板中。
* **添加其他 Tab：** 可以添加其他 Tab，展示不同的视图和信息，例如使用说明、不同的 Search Node 视图、相关节点的引用等。

### 4. Tag 配置面板

通过以下几种方式可以打开 Tag 配置面板：

* 右键点击 Supertag 并选择 "Config supertag"。
* 使用 Cmd/Ctrl+Shift+click 点击 Supertag。
* 在 Tag 页面点击节点选项 (省略号按钮) > "Configure supertag"。
* 在拥有该 Supertag 的节点上使用命令行执行 "Configure supertag" 命令。

### 5. Tag 模板

Tag 模板是 Supertag 的核心功能之一，它定义了 Supertag 所代表的对象的结构和属性。

* **内容模板：** 定义了每次应用 Supertag 时自动添加到节点的 Fields、Search Node 和普通节点。
    * **Fields：** 描述对象属性，例如 #task 的截止日期、优先级等。
    * **Search Node：** 根据 Supertag 实例自定义搜索结果，例如 #project 查找相关的 #task。
    * **普通节点：** 添加预设的节点内容。
* **继承：**  可以选择一个 Supertag 进行继承，子标签会继承父标签的模板内容，但子标签自定义的内容优先级更高。
* **可选字段：**  可以将一些不常用的 Fields 设置为可选字段，在需要时添加。
* **显示为复选框：** 可以将 Supertag 显示为复选框，并将其状态与 Fields 的值进行映射。
* **基础标签：**  可以选择一个基础类型，帮助 AI 识别节点的类型，例如会议、任务、组织、人物、地点等。

### 6. AI 和命令

Tag 配置面板的 AI 和命令部分可以配置 AI 功能和添加命令按钮。

* **自动填充：** 使用 AI 自动填充标题、Fields 或描述。
* **音频转录：**  添加录音按钮，将语音备忘录转录为文本内容。
* **命令面板：**  添加命令按钮，点击按钮即可触发预设的命令。
* **触发命令：**  在 Supertag 添加或删除时触发预设的命令。
* **AI 指令：**  为 AI 提供额外的指令，帮助其识别需要添加该 Supertag 的对象。

### 7. 高级选项

高级选项部分包含一些更复杂的功能。

* **构建标题：**  根据 Fields 的值自动生成节点标题。
* **默认子标签：**  为 Supertag 实例的所有子节点设置默认的 Supertag。
* **相关内容：**  自定义 Tag 实例的布局，展示相关引用或 Search Node。
* **快捷方式：**  添加指向其他节点的快捷方式。

### 8. Tag 定义节点

每个 Supertag 都有一个对应的 Tag 定义节点，存储该 Supertag 的所有配置信息。可以使用 "#[标签名称]" 的形式找到 Tag 定义节点。

### 9. Tag 的合并

可以使用 Tana 的合并功能将重复的 Supertag 合并为一个。 合并后，所有引用该 Supertag 的节点都会更新为指向新的 Supertag。


希望以上补充说明能够帮助您更好地理解 Tana 中 Tag 的概念和功能。 


## 03 org-supertag-field.el 的设计

### 3.1 字段详解

**SuperTag 字段是用于描述节点元数据的关键组件，类似于 org-mode 的 property 和 drawer。** 每个节点相当于一个数据库条目，字段则为该条目提供一致的信息。字段可以添加到任何节点，但更有效的方式是利用 Supertag 创建包含所需字段的模板。

### 3.2 字段类型

SuperTag 提供九种字段类型，每种类型都具有数据验证功能，确保数据的准确性：

* **普通字段 (Plain)**： 最灵活的类型，可写入任何内容，适用于不常重复或无需验证的数据，例如错误描述。
* **选项字段 (Options)**：提供下拉菜单，可从预设选项中选择。预设选项可预先定义，也可随新值添加自动收集。
* **来自 Supertag 的选项字段 (Options from supertag)**：基于具有特定 Supertag 的节点创建选项列表。输入新值时，Tana 会提示将其标记为相同的 Supertag。
* **日期字段 (Date)**：存储日期和时间信息，可设置日期粒度和提醒。
* **截止日期字段 (Due date)**：专门用于存储截止日期信息。
* **复选框字段 (Checkbox)**：提供一个可勾选的复选框，可用于跟踪任务完成状态。
* **数字字段 (Number)**：仅接受数字，支持表格视图中的计算，可设置最大/最小位数。
* **Tana 用户字段 (Tana user)**：提示输入工作区用户，目前功能仍在开发中。
* **URL 字段 (URL)**：存储 URL/外部链接。

### 3.3 字段配置

需要设计字段配置面板，可设置的选项包括：

* **字段类型**
* **默认值**
* **数据验证规则**
* **是否自动初始化**
* **是否隐藏字段**
* **是否为 AI 增强字段**
* **其他高级选项**

#### 3.3.1 面板实现方法
;;TODO

### 3.4 字段定义

**每个字段都有一个特殊的节点，称为字段定义，用于存储字段的设置。** 字段定义的位置决定了该字段的主要实例。删除字段定义或其所属节点时，其他地方使用的该字段将显示垃圾桶图标，以防止数据意外删除。

### 3.5 字段使用

字段可用于：

* **结构化信息**：为节点提供一致的信息，例如人物节点的姓名、电话号码、电子邮件地址等。
* **搜索和过滤**：使用 "Find nodes" 命令，可以根据字段值查找节点，例如查找所有标签为 #todo 且 Owner 为 John Doe 的节点。
* **分组和排序**：在表格视图中，可以根据字段对节点进行分组和排序。
* **自动生成标题**：使用 "Build title from field" 功能，可以根据字段值自动生成节点标题。

### 3.6 系统字段

SuperTag 还提供一些系统字段，用于存储节点的计算属性和系统定义的信息，例如：

* **计算系统字段**：例如节点的创建时间、修改时间、拥有者等。
* **系统定义字段**：例如日期字段、截止日期字段等。

### 3.7 字段的优势

使用字段可以帮助用户：

* **更好地组织信息**
* **更轻松地查找和过滤信息**
* **更高效地分析和利用信息**


## 04 org-supertag-db.el 的设计

### 4.1 关系映射

- 数据实体：file node tag field

* 只有标记了 supertag 的 headline 才视为 node

* node 记录两个属性：node-id、file-path。前者用于标记，以方便追踪。后者则是用于记录 Node 当前所在位置

* supertag 本身也记录 tag-id，该 id 与 node-id 关联

* 一个 node 可以标记多个 supertag

* 一个 supertag 可以标记多个 node

* 一个 node 可以有多个 field

* 一个 tag 可以无需添加 field

* 当 tag 只和它定义的一个或多个 field 相关联

* field 具备唯一性，field 的名称和类型唯一确定一个 field，用户不可创建名称重复的 field

* field 的实例，将储存在 node 的下方（以 property 的形式），但它的值也同时储存在 field-values 表中，双方保持一致

* field 通过创建 tag 模板的形式，与对应的 tag 进行关联

* node 不直接与 field 关联，而是通过 tag 关联 

### 4.2 哈希表实现方向

- 使用中间表，对多个分表
  - 中间表将储存多个表之间的映射关系
  - 中间表的作用在于，当一个分表的数据实体与关系发生变更时，可以通过中间表快速地进行同步到存在对应关系的分表中
  - 中间表提供一个统一的接口，用于访问所有分表的数据
- 使用 org-mode 的表格功能，展示 field type 以及 field template
  - 用户可以直接在表格中编辑 field type 以及 field template
  - 编辑后，保存文件，org-supertag 会自动加载最新的 field type 以及 field template

### 4.3 主要表结构

1. **节点表 (Nodes)**
```elisp
;; 存储所有节点的基本信息
(defvar org-supertag-nodes
  #s(hash-table
     ;; key: node-id
     ;; value: (title content parent-id created-time modified-time)
     data(
       "node1" ("标题1" "内容1" "parent1" "2024-03-20" "2024-03-21")
       "node2" ("标题2" "内容2" nil "2024-03-19" "2024-03-19")
     )))
```

2. **标签表 (Tags)**
```elisp
;; 存储所有标签的定义
(defvar org-supertag-tags
  #s(hash-table
     ;; key: tag-id
     ;; value: (tag-name parent-tag-id description)
     data(
       "task" ("Task" nil "任务类型标签")
       "project" ("Project" nil "项目类型标签")
     )))
```

3. **字段表 (Fields)**
```elisp
;; 存储标签可用的字段定义
(defvar org-supertag-fields
  #s(hash-table
     ;; key: field-id
     ;; value: (field-name field-type default-value)
     data(
       "status" ("Status" "select" "todo")
       "priority" ("Priority" "select" "p3")
     )))
```

4. **标签字段关系表 (Tag_Fields)**
```elisp
;; 存储标签和字段的关联
(defvar org-supertag-tag-fields
  #s(hash-table
     ;; key: tag-id
     ;; value: ((field-id1 . required) (field-id2 . optional))
     data(
       "task" (("status" . t) ("priority" . t))
       "project" (("due-date" . t) ("owner" . nil))
     )))
```

5. **节点标签关系表 (Node_Tags)**
```elisp
;; 存储节点和标签的关联
(defvar org-supertag-node-tags
  #s(hash-table
     ;; key: node-id
     ;; value: ((tag-id1 . timestamp1) (tag-id2 . timestamp2))
     data(
       "node1" (("task" . "2024-03-20") ("urgent" . "2024-03-20"))
       "node2" (("project" . "2024-03-19"))
     )))
```

6. **字段值表 (Field_Values)**
```elisp
;; 存储节点的字段值
(defvar org-supertag-field-values
  #s(hash-table
     ;; key: node-id
     ;; value: ((field-id1 . value1) (field-id2 . value2))
     data(
       "node1" (("status" . "in-progress") ("priority" . "p1"))
       "node2" (("due-date" . "2024-04-01"))
     )))
```


### 4.4 反向索引表

为了更好地处理标签关系变更的广播，我们可以考虑以下改进：

1. 反向索引：
   创建一个新的哈希表，用于存储每个标签被哪些节点使用：


2. 标签关系表：
   创建一个专门用于存储标签之间关系的哈希表：
 
3. 事件系统：
   实现一个简单的事件系统，用于在标签关系变更时触发回调：
 
   ```

4. 更新函数：
   实现一个函数来处理标签关系的变更并触发相应的事件：
  
   ```
这些改进将使得处理标签关系变更和广播变得更加高效和直接：

- 反向索引使我们能够快速找到受特定标签影响的所有节点。
- 专门的标签关系表使得管理和查询标签之间的关系变得更加简单。
- 事件系统允许我们在标签关系变更时灵活地触发各种操作，如更新UI、重新计算字段值等。

这种设计不仅能更好地处理标签关系变更的广播，还为未来可能的扩展（如复杂的继承规则、标签组合逻辑等）提供了基础。

您觉得这个改进方案如何？是否还有其他方面需要考虑？

### 4.5 序列化与反序列化

#### 4.5.1 从 Org 文件到内存 (反序列化)

**读取流程**:
1. **扫描 Headline**
   - 只处理带有 supertag 标记的 headline
   - 提取 node-id 和 file-path
   - 如果 headline 没有 node-id，则生成新的

2. **解析 Property Drawer**
   - field 值存储在 property drawer 中
   - 每个 field 对应一个 property
   - 将 field 值反序列化到内存中的哈希表

3. **建立关系映射**
   - node 和 tag 的关系
   - tag 和 field 的关系
   - field 值的存储

#### 4.5.2 从内存到 Org 文件 (序列化)

**写入流程**:
1. **更新 Headline**
   - 确保 headline 有正确的 node-id
   - 维护 file-path 的正确性

2. **更新 Property Drawer**
   - 将内存中的 field 值序列化到 property
   - 保持 property drawer 的格式
   - 只更新发生变化的部分

3. **维护数据一致性**
   - 确保 org 文件和内存数据的同步
   - 处理文件移动和重命名
   - 处理 headline 的移动

### 4.6 中间表的作用

中间表在这个过程中起到：
1. **缓存作用**
   - 避免频繁读写文件
   - 提供快速查询能力

2. **关系维护**
   - 跟踪 node 位置变化
   - 维护 tag 和 field 的关联
   - 支持复杂查询

3. **状态同步**
   - 追踪文件修改
   - 处理并发修改
   - 解决冲突

需要我详细展开某个具体部分吗？

## 05 org-element-api 的应用

### 5.1 为什么需要 org-element-api

- 提供结构化的语法树解析能力
- 支持精确的节点内容和属性获取
- 便于维护节点间的层级关系
- 提高搜索和展示效率

### 5.2 主要应用场景

1. **结构化解析**
   - 解析 headline 及其内容
   - 获取完整的节点属性
   - 维护节点间的层级关系

2. **搜索功能**
   - 基于语法树的快速搜索
   - 支持复杂的搜索条件
   - 结果的结构化展示

3. **内容关联**
   - 追踪关联节点
   - 导出节点及其上下文
   - 维护节点间的引用关系

4. **性能优化**
   - 实现解析结果缓存
   - 支持增量更新
   - 优化大文件处理性能

### 5.3 实现策略

1. **缓存层**
   - 缓存解析后的语法树
   - 监听文件变化
   - 实现增量更新

2. **搜索层**
   - 基于语法树的快速检索
   - 支持多维度搜索条件
   - 结果的格式化展示

3. **展示层**
   - 生成搜索结果视图
   - 支持上下文展示
   - 灵活的格式定制


### 5.4 数据流向

```elisp
(org-element) -> [解析层] -> [哈希表]
                    ^            |
                    |            v
                [缓存层] <- [序列化层] -> [org文件]
```

### 5.5 集成策略

1. **节点解析与存储**
   - 使用 org-element-api 解析文件结构
   - 将解析结果存入哈希表
   - 维护节点间的层级关系

2. **标签处理**
   - 从 headline 中提取 #tag-name 格式的标签
   - 更新标签关系表和反向索引
   - 处理标签继承关系

3. **字段管理**
   - 解析 property drawer 中的字段值
   - 更新字段值表
   - 维护字段与标签的关联

### 5.6 性能优化

1. **缓存机制**
   - 缓存 org-element 解析结果
   - 实现增量更新策略
   - 监听文件变化

2. **查询优化**
   - 结合语法树和哈希表进行搜索
   - 利用反向索引加速查询
   - 支持复杂的过滤条件

3. **同步策略**
   - 文件变化时更新内存数据
   - 内存数据变化时更新文件
   - 处理并发修改


## 06 API 设计策略

1. **核心 API 分类**
   - **Node 操作**
     - 创建/读取/更新/删除节点
     - 节点关系管理（父子、引用）
     - 节点内容操作
     - 节点位置追踪

   - **Tag 操作**
     - 标签定义和管理
     - 标签关系维护
     - 标签继承规则
     - 标签字段配置

   - **Field 操作**
     - 字段值的读写
     - 字段类型管理
     - 字段验证规则
     - 字段默认值

2. **API 设计原则**
   - **一致性**
     - 统一的命名规范
     - 一致的参数顺序
     - 标准的返回格式
     - 统一的错误处理

   - **原子性**
     - 单一职责
     - 事务支持
     - 状态一致性
     - 回滚机制

   - **可扩展性**
     - 模块化设计
     - 钩子机制
     - 事件系统
     - 中间件支持

3. **错误处理策略**
   - **错误分类**
     - 参数错误
     - 数据一致性错误
     - 并发冲突
     - 系统错误

   - **错误恢复**
     - 自动重试机制
     - 数据回滚
     - 错误日志
     - 用户通知

4. **事件通知系统**
   - **事件类型**
     - 节点变更
     - 标签更新
     - 字段修改
     - 关系变化

   - **订阅机制**
     - 事件注册
     - 事件过滤
     - 异步处理
     - 优先级控制

## 07 数据持久化策略

1. **存储结构**
   - **文件组织**
     - 主数据文件
     - 索引文件
     - 缓存文件
     - 临时文件

   - **存储位置**
     - 用户配置目录
     - 项目相关目录
     - 临时文件目录
     - 备份存储位置

2. **持久化机制**
   - **写入策略**
     - 即时写入
     - 延迟写入
     - 批量写入
     - 增量更新

   - **数据格式**
     - 序列化格式
     - 压缩策略
     - 版本控制
     - 向后兼容

3. **数据安全**
   - **备份策略**
     - 自动备份
     - 增量备份
     - 版本管理
     - 备份恢复

   - **错误恢复**
     - 事务日志
     - 检查点机制
     - 崩溃恢复
     - 数据验证

4. **性能优化**
   - **缓存策略**
     - 内存缓存
     - 磁盘缓存
     - 缓存失效
     - 缓存同步

   - **I/O 优化**
     - 批量操作
     - 异步写入
     - 压缩存储
     - 索引优化

5. **数据迁移**
   - **版本升级**
     - 数据格式升级
     - 兼容性处理
     - 增量迁移
     - 回滚机制

   - **数据导入导出**
     - 格式转换
     - 批量导入
     - 选择性导出
     - 数据校验

## 08 同步策略设计

1. **Buffer 状态追踪**
   - **修改状态标记**
     - 记录每个 buffer 的最后修改时间
     - 追踪未保存的修改
     - 检测外部修改

   - **Buffer 间同步**
     - 同一文件的多个 buffer 同步
     - 修改广播机制
     - 状态一致性检查

2. **数据同步机制**
   - **内存与文件同步**
     - 定期自动保存
     - 显式保存触发
     - 增量更新策略

   - **缓存同步**
     - 缓存失效检测
     - 按需更新缓存
     - 避免重复解析

3. **冲突处理**
   - **检测策略**
     - 时间戳比对
     - 内容哈希比对
     - 修改状态检查

   - **解决方案**
     - 用户确认机制
     - 自动合并策略
     - 保留修改历史

4. **状态恢复**
   - **会话恢复**
     - 保存编辑状态
     - 恢复打开的 buffer
     - 恢复未保存的修改

   - **错误恢复**
     - 临时文件备份
     - 编辑历史记录
     - 回滚机制

这个同步策略主要关注数据一致性和用户体验，避免数据丢失或冲突。您觉得这个设计方向如何？需要补充或调整吗？


##  org-supertag-db.el 实现计划

### 9.1 核心功能（最高优先级）

1. **基础数据表结构**
   - Nodes 表：存储节点基本信息
   - Tags 表：存储标签定义
   - Fields 表：存储字段定义
   - Tag_Fields 表：标签和字段关联
   - Node_Tags 表：节点和标签关联
   - Field_Values 表：存储字段值

2. **基本序列化/反序列化**
   - org 文件到内存的解析
   - 内存数据到 org 文件的写入
   - property drawer 的处理

3. **org-element-api 基础集成**
   - headline 解析
   - 节点内容获取
   - 基本的结构化数据处理

### 9.2 次要功能（第二优先级）

1. **反向索引**
   - 标签到节点的映射
   - 快速查询支持

2. **简单的同步策略**
   - buffer 修改状态追踪
   - 基本的文件同步机制

3. **基础缓存机制**
   - org-element 解析缓存
   - 简单的增量更新

### 9.3 未来扩展（可延后）

1. **高级特性**
   - 复杂查询优化
   - 完整的事件系统
   - 高级缓存策略

2. **数据安全**
   - 完整的备份机制
   - 详细的错误恢复

3. **性能优化**
   - 高级索引优化
   - 复杂的缓存策略

这样的优先级划分如何？我们可以先专注于核心功能的实现，为未来的扩展预留接口。




是的，让我们为 MVP 添加必要的 API 设计：

### 10 核心 API（最高优先级）

1. **Node 基础操作**
   - 创建节点
   - 读取节点
   - 更新节点
   - 删除节点
   - 获取节点内容

2. **Tag 基础操作**
   - 添加标签
   - 删除标签
   - 获取节点的标签
   - 获取标签的节点

3. **Field 基础操作**
   - 设置字段值
   - 获取字段值
   - 获取标签的字段定义

### 10.2 辅助 API（第二优先级）

1. **查询接口**
   - 按标签查询节点
   - 按字段值查询
   - 基本的组合查询

2. **同步接口**
   - 保存更改
   - 刷新节点状态
   - 检查修改状态

3. **事件通知**
   - 节点更新通知
   - 标签变更通知
   - 基本的错误通知

### 10.3 未来扩展 API（可延后）

1. **高级查询**
   - 复杂条件查询
   - 全文搜索
   - 关系查询

2. **批量操作**
   - 批量更新
   - 批量导入导出
   - 批量标签操作

3. **管理接口**
   - 缓存管理
   - 索引维护
   - 状态监控

